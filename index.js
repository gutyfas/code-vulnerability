
import React, { Component } from 'react';
import { MainContent, MainContentHeader, MainContentBody } from "../../../../layouts/common/maincontent";
import VehicleReadingList from './vehicleReadingList';
import { VehicleReadingsFilters } from '../filter/vehicleReadingsFilters';
import Message from '../../../../common/message/message';
import { Container } from 'react-bootstrap';
import { GetFieldValue } from '../../../../common/localization/text.localized';
import { Helmet } from "react-helmet";
import * as vehicleSearchEnums from '../../../../../services/VehicleSearch/enums';
import { Text, FormatFieldValue } from "../../../../common/localization/text.localized";
import "./readings.scss";
import { GoogleAnalytics } from '../../../../../webconfig'
import ReactGA from 'react-ga';
import * as VehicleSearchService from '../../../../../services/VehicleSearch/vehicleSearchService'
import * as OdometerService from '../../../../../services/odometerService'
import { Link } from 'react-router-dom';
import { GetCurrentUser, vehiclesAssocited} from '../../../../../services/userDataService';
import { MeasurementSystem } from '../../../../helpers/enumerators';
import { ToastContainer, toast } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';
import { ExportCSV } from './ExportCSV';
import { ExportCSVNoLastBilled } from './Exports/ExportCSVNoLastBilled';
import { cancelPendingGraphQLRequest } from '../../../../helpers/apiHelper';
import Icon from '../../../../common/icons/icon';
import { Dropdown, DropdownButton} from 'react-bootstrap';
import moment from 'moment';
import { SetLocalStorage, GetLocalStorage } from '../../../../../services/sessionCache';
import Confirmation from '../../../../common/confirmation/confirmation';
import { Prompt } from 'react-router-dom';
import { withRouter } from 'react-router-dom';
import ContactUsMessage from '../../../../common/contactUsMessage/contactUsMessage';

let MAX_RECORDS = 1000;

//XLSX library is big so we read it dynamically to prevent the big initial bundle size
const getXLSX = () => import(/*webpackChunkName: "xlsx" */ 'xlsx');

export class Readings extends Component {
    showButton = false;
    hasData = false;
    readyToExport = false;
    readingsImported = [];
    readingsToReport = [];
    pendingEntry = false;
    constructor(props) {
        super(props);
        let initialTerm = "";
        if (props.location && props.location.state) {
            if (props.location.state.term)
                initialTerm = props.location.state.term;
        } else if (props.location && props.location.query)
        {
            initialTerm = props.location.query.unitNumber;
        }
        const userProfile = GetCurrentUser();
        this.btnRef= React.createRef();
        this.state = {
            loading: (typeof props?.location?.loading !== "undefined") ? props?.location?.loading : false,
            vehicles: [],
            total: 0,
            page: 1,
            hasMoreData: true,
            isDisconnected: false,
            filters: {
                term: initialTerm,
                viewBy: vehicleSearchEnums.ViewNames.vehicleNumber,
                sortBy: vehicleSearchEnums.SortByNames.vehicleNumber,
                filterBy: vehicleSearchEnums.FilterByNames.isBilledByMileage,
                vehicleBy: []
            },
            showVehicleSearchErrorMessage: false,
            vehicleSearchErrorMessage: "",
            vehicleSearchErrorRedirectTo: '/vehicles',
            firstLoad: true,
            readings: [],
            unitSystem: userProfile ? userProfile.unitOfMeasure : MeasurementSystem.Imperial,
            fileName: 'Readings',
            template: 'Template',
            sharedAccounts: [],
            facets: [],
            accounts: [],
            showVehicleNotFoundMessage: false,
            showNoLeaseMessage: false,
            modalVisible: false,
            lastLocation: null,
            confirmedNavigation: false,
            pendingEntry: false,
            pendingSearch: false,
            refreshSearch: false,
            cancelSearch: false,
            allVehicles: [],
            uploadErrorMessage: false,
            uploadBackendErrorMessage: false
        }

        console.log(this.state.loading, "loading")
        window.addEventListener("beforeunload", this.handleUnload.bind(this));
        window.onoffline = (event) => {
            this.handleConnectionChange();
        };
        window.ononline = (event) => {
            this.handleConnectionChange();
        };
        this.executeSearch = this.executeSearch.bind(this);
        this.handleVehicleSearchResponse = this.handleVehicleSearchResponse.bind(this);
        this.handleUnauthenticatedUser = this.handleUnauthenticatedUser.bind(this);
        this.handleVehicleSearchGeneralError = this.handleVehicleSearchGeneralError.bind(this);
        this.fetchMoreData = this.fetchMoreData.bind(this);
        this.handleVehicleFetchMoreDataResponse = this.handleVehicleFetchMoreDataResponse.bind(this);
        this.handleBlockedNavigation = this.handleBlockedNavigation.bind(this);
        this.handleConfirmNavigationClick = this.handleConfirmNavigationClick.bind(this);
    }

    handleUnload(event) {
        if(this.showButton) {
            const e = event || window.event;
            e.returnValue = 'leave page?';
        }
    }

    showModal = (location) => {
        this.setState({
            modalVisible: true,
            lastLocation: location,
        })
    } 

    closeModal() {
        this.setState({
            modalVisible: false
        }, () => {
          if(!this.state.confirmedNavigation) {
            const self = this;
            this.warningTimeout = setTimeout(() => {
               self.setState({pendingEntry: this.pendingEntry, pendingSearch: false, cancelSearch: true});
            }, 1000);
          }
        })
    }
      
    handleBlockedNavigation = (nextLocation) => {
        if (!this.state.confirmedNavigation && this.showButton){
            this.showModal(nextLocation);
            return false
        }
        return true
    }

    handleConfirmNavigationClick () {
        const {navigate} = this.props
        const {lastLocation} = this.state
        if (lastLocation) {
           this.setState({
              confirmedNavigation: true,
              pendingEntry: false,
              modalVisible: false
           }, () => {
              this.showButton = false;
              this.pendingEntry = false;
              if(lastLocation.pathname) {
                this.props.history.push({ pathname: lastLocation.pathname});
              }
           })
        }
        if (this.state.pendingSearch) {
            this.setState({ modalVisible: false, cancelSearch: false });
            this.searchVehicles();
        }
    }

    componentDidMount() {
        clearTimeout( this.warningTimeout);
        this.executeSearch();
        const logOutElement = document.getElementById('rg-hd-username');
        logOutElement.addEventListener('click', this.handleBlockedNavigation.bind(this))
    }
    handleConnectionChange = () => {
        console.log(this.state.loading, "loading in handleConnection")
        const condition = navigator.onLine ? 'online' : 'offline';
        console.log(condition, "condition")
        if (condition === 'online') {
          const webPing = setInterval(
            () => {
              fetch('//google.com', {
                mode: 'no-cors',
                })
              .then(() => {
                this.setState({ isDisconnected: false }, () => {
                    if(this.state.loading) {
                        this.executeSearch();
                    }
                  return clearInterval(webPing)
                });
              }).catch(() => this.setState({ isDisconnected: true, loading: false }) );
            }, 2000);
          return;
        }
        return this.setState({ isDisconnected: true, loading: false }, this.showToastMessage(GetFieldValue("noInternetConnectionMessage")));
      }

    componentWillUnmount() {
        cancelPendingGraphQLRequest();
        window.removeEventListener('online', this.handleConnectionChange);
        window.removeEventListener('offline', this.handleConnectionChange);
        window.removeEventListener('beforeunload', this.handleUnload);
    }

    searchVehicles(filters, refreshSearch) {
        if(filters || refreshSearch) {
            this.setState({ refreshSearch: refreshSearch || this.state.loading, firstLoad: true, filters: filters });
        }
        if(this.state.readings.length > 0 && !this.state.pendingSearch) {
           this.setState({pendingSearch: true});
           this.showModal();
        } else {
            if(!this.state.cancelSearch) {
                this.setState({ pendingSearch: false, loading: this.state.refreshSearch }, () => {
                    if (this.state.refreshSearch) {
                        this.executeSearch();
                    }
                });
            }
        }
    }

    executeSearch() {
        this.setState({ loading: true, vehicles: [], page: 1, readings: [] }, () => {
            this.registerGoogleAnalyticEvent(GoogleAnalytics.Actions.Vehicle_Search_fromList);
            VehicleSearchService.SearchVehiclesByCustomer(this.state.filters,
                this.handleVehicleSearchResponse,
                MAX_RECORDS,
                1);
        });
    }

    handleVehicleSearchResponse(response) {
        switch (response.status) {
            case 200:
                if (response.data && response.data.data && response.data.data.driver) {
                    //Check for Authenticated User
                    const driver = response.data.data.driver;
                    if (!driver.authenticated) {
                        this.setState({ loading: false, firstLoad: false, hasMoreData: false }, () => {
                            this.handleUnauthenticatedUser();
                        });
                    }
                    else {
                        let hasMoreData = (!driver?.units?.results || driver?.units?.results?.length === 0) ? false : true;
                        hasMoreData = (hasMoreData && driver.units.results.length < MAX_RECORDS) ? false : hasMoreData;

                        this.hasData = true;

                        let showVehicleNotFoundMessage = (driver?.units?.results === null || driver?.units?.results?.length === 0) ? true : false;
                        let hasNoVehicles = (driver?.units?.results === null || driver?.units?.results?.length === 0);
                        let hasAccount = (driver?.accounts?.length > 0 || driver?.accounts !== null)
                        let hasSharedAccount = (driver?.sharedAccounts?.length > 0 || driver?.sharedAccounts !== null);

                        let showNoLeaseMessage = hasNoVehicles && (hasAccount || hasSharedAccount);

                        if (GetLocalStorage(vehiclesAssocited) === null) {
                            SetLocalStorage(vehiclesAssocited, !showNoLeaseMessage);
                        }

                        if (!GetLocalStorage(vehiclesAssocited)) {
                            showVehicleNotFoundMessage = false;
                        } else {
                            showNoLeaseMessage = false;
                        }

                        if (!this.state.refreshSearch) {
                            this.setState({allVehicles: driver.units.results});
                        }

                        this.setState({
                            loading: false,
                            vehicles: driver.units.results,
                            total: driver.units.count,
                            firstLoad: false,
                            hasMoreData,
                            sharedAccounts: driver?.sharedAccounts,
                            accounts: driver?.accounts,
                            showVehicleNotFoundMessage: showVehicleNotFoundMessage,
                            showNoLeaseMessage: showNoLeaseMessage,
                            facets: driver?.units?.facets
                        });
                    }
                }
                break;
            default:
                this.hasData = false;
                this.setState({ loading: false, firstLoad: false, hasMoreData: false }, () => {
                    this.handleVehicleSearchGeneralError();
                });
                break;
        }
    }

    handleUnauthenticatedUser() {
        if (!this.state.showVehicleSearchErrorMessage)
            this.setState({
                showVehicleSearchErrorMessage: true, vehicleSearchErrorMessage: GetFieldValue("unauthenticatedUserMessage"),
                vehicleSearchErrorRedirectTo: '/login'
            });
    }

    handleVehicleSearchGeneralError() {
        if (!this.state.showVehicleSearchErrorMessage)
            this.setState({ showVehicleSearchErrorMessage: true, vehicleSearchErrorMessage: GetFieldValue("VehicleSearchGeneralErrorMessage") });
    }

    registerGoogleAnalyticEvent(label) {
        ReactGA.event({
            category: GoogleAnalytics.Categories.View_Preference,
            action: GoogleAnalytics.Actions.View_Preference_Vehicles,
            label: label
        });
    }

    registerReadingsGoogleAnalyticEvent(label) {
        ReactGA.event({
            category: GoogleAnalytics.Categories.My_Vehicles,
            action: GoogleAnalytics.Actions.Odometer_Action,
            label: label
        });
    }

    handleOnOkayVehicleSearchErrorMessage() {
        const redirecTo = this.state.vehicleSearchErrorRedirectTo;
        this.setState({ showVehicleSearchErrorMessage: false, vehicleSearchErrorMessage: null, vehicleSearchErrorRedirectTo: null }, () => {
            if (redirecTo)
                this.props.history.push({ pathname: redirecTo, state: { hasAccessToVehicles: true } });
        });
    }

    saveValues = () => {
        this.showButton = false;
        if(this.btnRef.current){
            this.btnRef.current.setAttribute("disabled", "disabled");
        }
        var readings = this.state.readings;
        const isFileUpload = false;
        if(readings?.length > 0) {
            this.setState({ loading: true });
            this.registerReadingsGoogleAnalyticEvent(GoogleAnalytics.Labels.Odometer_SaveReadings);
            OdometerService.SubmitOdometerReadings(readings, isFileUpload, (data) => { this.handleSubmitOdometerResponse(data) });
        }
    }

    fetchMoreData() {
        this.setState({ page: this.state.page + 1 }, () => {
            VehicleSearchService.SearchVehiclesByCustomer(this.state.filters,
                this.handleVehicleFetchMoreDataResponse,
                MAX_RECORDS,
                this.state.page,
                true);
        });
    }

    handleVehicleFetchMoreDataResponse(response) {
        switch (response.status) {
            case 200:
                if (response.data && response.data.data && response.data.data.driver) {
                    //Check for Authenticated User
                    const driver = response.data.data.driver;
                    if (!driver.authenticated) {
                        this.setState({ loading: false, firstLoad: false, hasMoreData: false }, () => {
                            this.handleUnauthenticatedUser();
                        });
                    }
                    else {
                        let vehiclesData = this.state.vehicles;
                        let hasMoreData = true;

                        //if (driver?.units?.results?.length > 0) {
                        if (driver.units.results && driver.units.results.length > 0) {
                            vehiclesData = vehiclesData.concat(driver.units.results);
                            hasMoreData = (hasMoreData && driver.units.results.length < MAX_RECORDS) ? false : hasMoreData;
                            this.setState({total: driver.units.count});
                        }
                        else {
                            hasMoreData = false;
                        }

                        this.setState({ vehicles: vehiclesData, hasMoreData, firstLoad: false },  () => {
                            this.readyToExport = true;
                        });
                    }
                }
                break;
            default:
                this.setState({ loading: false, firstLoad: false, hasMoreData: false }, () => {
                    this.handleVehicleSearchGeneralError();
                });
                break;
        }
    }

    handleSubmitOdometerResponse(data) {
        let toastMessage = GetFieldValue('readingSavedSuccessMessage');
        if((data && data.hasError) || !data || data.submitOdometerReadings === false || data === 'timeout') {
            toastMessage = GetFieldValue('readingSavedErrorMessage');
        }

        toast.success(toastMessage, {
            position: "top-center",
            autoClose: 5000,
            hideProgressBar: false,
            closeOnClick: true,
            pauseOnHover: false,
            draggable: true,
            progress: undefined,
            });
        this.setState({ readings: [] });
        if (data && !data.hasError) {
            this.executeSearch();
        } else {
            this.setState({loading: false});
        }
    }

    setReadings(data, pendingEntry) {
        this.setState({readings: data, pendingEntry: false});
        this.pendingEntry = pendingEntry;
        this.showButton = data?.length > 0 ? true : false;
    }

    onFileUpload(file) {
        const ext = file.name.substr(file.name.length - 4);
        if (file && (ext === 'xlsx' || ext === '.xls')) {
            this.registerReadingsGoogleAnalyticEvent(GoogleAnalytics.Labels.Odometer_UploadFile);
            const promise = new Promise((resolve, reject) => {
                getXLSX().then(XLSX => {
                    const fileReader = new FileReader();
                    fileReader.readAsArrayBuffer(file);

                    fileReader.onload=(e)=> {
                        const bufferArray = e.target.result;
                        const fileConfig =  XLSX.read(bufferArray, {type: 'buffer' });
                        const fileName = fileConfig.SheetNames[0];
                        const fileData = fileConfig.Sheets[fileName];
                        let data = '';
                        let isSpecialDoc = false;
                        fileConfig.Strings.map(text => {
                            if(text['r']) {
                                let t = text['r'].split("\n").join(' ');
                                if( t === 'Current Reefer Standby Hours') {
                                    isSpecialDoc = true;
                                }
                            }
                        })
                        if (isSpecialDoc) {
                            data = XLSX.utils.sheet_to_json(fileData, {range: 7} );
                        } else  {
                            data = XLSX.utils.sheet_to_json(fileData, {raw: false});
                        }
                        resolve(data);
                    };

                    fileReader.onerror = ((error) => {
                        reject(error)
                    })
                });
            })

            promise.then((data) => {

                let vehicleList = [];
                if (data.length > 0) {
                      data.forEach((entry, i) => {
                        let totalDays = 0;

                        const isDateValid = entry.validateDate ? this.validateDate(entry.ReadingDate) : true;

                        if(!entry.ReadingDate || entry.ReadingDate.indexOf(':') === -1) {
                            entry.ReadingDate = this.formatEntryDate(entry.ReadingDate, false);
                        }
                        
                        if (!entry.RyderVeh) {

                            const isDataValid = this.validateData(entry);

                            if(isDateValid && isDataValid) {
                                const newdate = moment(new Date());
                                const diffDuration = moment.duration(newdate.diff(entry.ReadingDate));
                                totalDays = diffDuration.asDays();
                                const currentReading = this.state.allVehicles.filter(vehicle => {
                                    return vehicle.unitSummary.unitNumber === entry.VehicleNumber;
                                });

                                const readingsDateDiff = moment.duration(moment(new Date(entry.ReadingDate)).diff(currentReading[0].vehicleOdometer.lastReadingDate)).asDays();

                                if(currentReading.length > 0) {
                                    if(readingsDateDiff > 1 ) {
                                        vehicleList = this.validateEnteredReading(currentReading, totalDays, entry, vehicleList);
                                    } else {
                                        vehicleList = this.isBiggerReading(entry, +entry.CurrentReadingOdometer, +currentReading[0].vehicleOdometer.lastOdometerReading, +currentReading[0].vehicleOdometer.billedOdometer, currentReading, totalDays, vehicleList);

                                        vehicleList = this.isBiggerReading(entry, +entry.CurrentReadingReeferHours, +currentReading[0].vehicleOdometer.lastReeferHoursReading, +currentReading[0].vehicleOdometer.billedReeferHours, currentReading, totalDays, vehicleList);

                                        vehicleList = this.isBiggerReading(entry, +entry.CurrentReadingStandByHours, +currentReading[0].vehicleOdometer.lastStandByHoursReading, +currentReading[0].vehicleOdometer.billedStdByHours, currentReading, totalDays, vehicleList);
                                    }
                                }
                            } else {
                                this.readingsToReport.push(entry);
                            }

                        } else {
                            let newEntry = this.replaceSpecialCharacters(entry);
                            const date = moment(new Date()).format("MM/DD/YYYY HH:mm:ss");
                            if (newEntry.hasOwnProperty('CurrentOdomHub')) {
                                vehicleList.push(entry.RyderVeh);
                                this.readingsImported.push({
                                    vehicleNumber: newEntry.RyderVeh ? newEntry.RyderVeh.toString() : null,
                                    miles: newEntry.CurrentOdomHub ? +newEntry.CurrentOdomHub : null,
                                    reeferHours: newEntry.CurrentReeferHours ? +newEntry.CurrentReeferHours : null,
                                    standByHours: newEntry.CurrentStandBy ? +newEntry.CurrentStandBy : null,
                                    shouldPostponeBilling: false,
                                    readingDate: date
                                    });
                            } else {
                                if (newEntry.hasOwnProperty('RyderVeh') && typeof newEntry.CustVeh === 'number') {
                                    vehicleList.push(entry.RyderVeh);
                                    this.readingsImported.push({
                                        vehicleNumber: newEntry.RyderVeh ? newEntry.RyderVeh.toString() : null,
                                        miles: newEntry.CustVeh ? +newEntry.CustVeh : null,
                                        reeferHours: null,
                                        standByHours:null,
                                        shouldPostponeBilling: false,
                                        readingDate: date
                                        });
                                }
                            }
                        }
                    })
                    if(!this.state.isDisconnected) {
                        if (vehicleList.length > 0) {
                            this.setState({ loading: true });
                            OdometerService.getVehicleBelongToCustomer(vehicleList, (data) => { this.handleVehicleBelongToCustomerResponse(data, this.readingsImported) });
                        } else {
                            this.showUploadError();
                        }
                    } else {
                        this.showToastMessage(GetFieldValue('noInternetMessage'));
                    }
                } else {
                    this.showUploadError();
                }
            })
        } else {
            this.showUploadError();
        }
    }

    isBiggerReading(entry, entryUpdated, lastEntered, lastBilled, currentReading, totalDays, vehicleList) {
        if(entryUpdated && entryUpdated !== lastEntered) {
            if(entryUpdated > 0 && entryUpdated > lastBilled) {
                 vehicleList = this.validateEnteredReading(currentReading, totalDays, entry, vehicleList);
            } else {
                 this.readingsToReport.push(entry);
            }
        }
        return vehicleList;
    }

    validateEnteredReading(currentReading, totalDays, entry, vehicleList) {
        if(currentReading.length > 0 ) {
            if (totalDays < 0 && +entry.CurrentReadingOdometer > +currentReading[0].vehicleOdometer.lastOdometerReading) {
                totalDays = 1;
                entry.ReadingDate = this.formatEntryDate(entry.ReadingDate, true);
            }
        }
        if(totalDays > 0 ) {
            if(entry.CurrentReadingOdometer || entry.CurrentReadingReeferHours || entry.CurrentReadingStandByHours) {
                if(entry.LastBilledThroughDate) {
                    const date = moment(new Date(entry.ReadingDate));
                    const diff = moment.duration(date.diff(entry.LastBilledThroughDate));
                    let days = diff.asDays();
                    if(currentReading.length > 0 && days < 0 && +entry.CurrentReadingOdometer > +currentReading[0].vehicleOdometer.lastOdometerReading) {
                        entry.ReadingDate = this.formatEntryDate(entry.ReadingDate, true);
                        days = 1;
                        vehicleList.push(entry.VehicleNumber);
                        this.addFormatedReading(entry);
                    } else if((currentReading.length === 0) || (days < 0 && currentReading.length > 0 && +entry.CurrentReadingOdometer < +currentReading[0].vehicleOdometer.lastOdometerReading)) {
                        this.readingsToReport.push(entry);
                    } else {
                        vehicleList.push(entry.VehicleNumber);
                        this.addFormatedReading(entry);
                    }
                } else {
                    vehicleList.push(entry.VehicleNumber);
                    this.addFormatedReading(entry);
                }
            }
        } else {
            this.readingsToReport.push(entry);
        }

        return vehicleList;
    }

    showUploadError() {
        this.setState({uploadErrorMessage: true});      
        this.readingsToReport = [];
        this.readingsImported = [];
    }

    formatEntryDate(readingDate, isFutureDate) {
        if(!readingDate || isFutureDate) {
            return moment(new Date()).format("MM/DD/YYYY HH:mm:ss");
        }

        const newTime = moment(new Date()).format("HH:mm:ss");
        const newDate = moment(new Date(readingDate)).format("MM/DD/YYYY " + newTime);
        return newDate;
    }

    validateDate(readingDate) {
        const formattedDate = new Date(readingDate);
        let entryDate = readingDate.split('/');
        if(entryDate[2].length < 4) {
            entryDate[2] = '20' + entryDate[2];
        }
        if(entryDate[0][0] === '0') {
            entryDate[0] = entryDate[0][1];
        }

        if(entryDate[1][0] === '0') {
            entryDate[1] = entryDate[1][1];
        }
        entryDate = entryDate.join('/');
        const newFormattedDate = ((formattedDate.getMonth() > 8) ? (formattedDate.getMonth() + 1) : ((formattedDate.getMonth() + 1))) + '/' + ((formattedDate.getDate() > 9) ? formattedDate.getDate() : (formattedDate.getDate())) + '/' + formattedDate.getFullYear();
        return entryDate === newFormattedDate;
    }

    validateData(entry) {
        const miles = !entry.CurrentReadingOdometer || entry.CurrentReadingOdometer % 1 === 0 ? true : false;
        const reefer =  !entry.CurrentReadingReeferHours || entry.CurrentReadingReeferHours % 1 === 0 ? true : false;
        const standBy = !entry.CurrentReadingStandByHours || entry.CurrentReadingStandByHours % 1 === 0 ? true : false;

        return miles && reefer && standBy;
    }

    addFormatedReading(entry) {
        const newDate = moment(new Date()).format("MM/DD/YYYY HH:mm:ss");
        this.readingsImported.push({
            vehicleNumber: entry.VehicleNumber ? entry.VehicleNumber : null,
            miles: entry.CurrentReadingOdometer ? +entry.CurrentReadingOdometer : null,
            reeferHours: entry.CurrentReadingReeferHours ? +entry.CurrentReadingReeferHours : null,
            standByHours: entry.CurrentReadingStandByHours ? +entry.CurrentReadingStandByHours : null,
            shouldPostponeBilling: false,
            readingDate: newDate
        });
    }

    replaceSpecialCharacters(entry) {
        let keys = Object.keys(entry);
        let newEntry = [];
        for (var j=0; j < keys.length; j++) {
           var key = keys[j].replace(/(\s|\u21b5|#|\/)/g, "");
           newEntry[key] = entry[keys[j]];
        }
        return newEntry;
    }

    handleVehicleBelongToCustomerResponse(data, readings) {
        let filtered = [];
        if(data.vehiclesBelongToCustomer && data.vehiclesBelongToCustomer.length > 0) {
            readings.filter(reading => {
                let index = data.vehiclesBelongToCustomer.indexOf(reading.vehicleNumber);
                if(index !== -1) {
                    filtered.push(reading);
                } else {
                    this.readingsToReport.push(reading);
                }
             })
        }
        if (filtered.length > 0) {
            const isFileUpload = true;
            OdometerService.SubmitOdometerReadings(filtered, isFileUpload, (data) => { this.handleUploadOdometerResponse(data) });
        } else {
            this.readingsToReport = [];
            this.readingsImported = [];
            this.setState({loading: false});
            this.showUploadError();
        }
    }

    handleUploadOdometerResponse(data) {
        const success = data && data.submitOdometerReadings === true ? true : false;
        let toastMessage = success === true ? GetFieldValue('dataUploadedSuccessMessage') : '';
        if(success && (this.readingsToReport === null || this.readingsToReport?.length === 0)) {
            this.showToastMessage(toastMessage);
        } else if (!success) {
            this.setState({uploadBackendErrorMessage: true});
        } else if (this.readingsToReport?.length > 0) {
            this.setState({uploadErrorMessage: true});
        }

        this.readingsToReport = [];
        this.readingsImported = [];

        this.executeSearch();
    }

    showToastMessage(message) {
        toast.success(message, {
            position: "top-center",
            autoClose: 5000,
            hideProgressBar: false,
            closeOnClick: true,
            pauseOnHover: false,
            draggable: true,
            progress: undefined,
            });
    }

    handleHoverEvent() {
        this.registerReadingsGoogleAnalyticEvent(GoogleAnalytics.Labels.Odometer_DownloadInfo);
    }

    loadAllforExport() {
        MAX_RECORDS = this.state.total;
        this.fetchMoreData();
        this.readyToExport = true;
    }

    hideUploadErrorMessage() {
        this.setState({ uploadErrorMessage: false });
    }

    hideUploadBackendErrorMessage() {
        this.setState({ uploadBackendErrorMessage: false });
    }

    render() {
        const { loading, filters, vehicles, sharedAccounts, accounts, showNoLeaseMessage, pendingEntry} = this.state;
        const fields = this.props.location.fields;
        const {when} = this.props
        const {modalVisible, lastLocation} = this.state
        return (
          <MainContent className="readings-page-container">
            <div className="back-button-container">
              <div className="back-button">
              <Link onMouseDown={this.registerReadingsGoogleAnalyticEvent(GoogleAnalytics.Labels.Odometer_VehicleLink)} to={{ pathname: '/vehicles' }}>
                  {GetFieldValue('backToMyVehicles')}
                </Link>
                <Link className="reading-history" onClick={this.registerReadingsGoogleAnalyticEvent(GoogleAnalytics.Labels.Odometer_VehicleLink)} to={{ pathname: '/vehicles/readings/uploadhistory' }}>
                  {GetFieldValue('viewUploadHistory')}
                </Link>
              </div>
            </div>
            <MainContentHeader>
              <Container className="container-box" id="profileContainer">
                <div className="rg-authenticated rg-readings-page">
                  <div>
                    <Helmet>
                      <meta name="robots" content="noindex,nofollow" />
                    </Helmet>
                  </div>
                  <div className="container container-box rg-readings-page">
                    <div className="row header-content">
                      <div className="header-container">
                        <Text tag="h2" className="header" field={GetFieldValue('readings')} /> {loading || !this.state.total ? '' : '(' + this.state.total + ')'}
                      </div>
                      <div className="links-container">
                        <div className="import-file">
                          <div className="links-container">
                            <Icon name="upload-icon" />
                            <span className="upload-icon">{GetFieldValue('uploadMultipleReadings')}</span>
                            <input
                              type="file"
                              className="upload-icon-input"
                              onChange={(e) => {
                                const file = e.target.files[0];
                                this.onFileUpload(file);
                              }}
                              onClick={(event) => {
                                event.target.value = null;
                              }}
                            ></input>
                          </div>
                        </div>
                        <div className="dropdown-container ml-5">
                          <div className="filter-sortby">
                            <title id="sort-by-titlereading-id">Download</title>
                            <span>Download: </span>
                            <DropdownButton title={'Template'} bsPrefix="rg-mv-fltr" className="alignRight">
                              <Dropdown.Item className="template-item">
                                <ExportCSV vehicles={vehicles} unitSystem={this.state.unitSystem} fileName={this.state.fileName} label={GetFieldValue('downloadReadings')}/>
                              </Dropdown.Item>
                              <Dropdown.Item className="template-item">
                                <ExportCSVNoLastBilled vehicles={vehicles} unitSystem={this.state.unitSystem} fileName={this.state.template} label={GetFieldValue('downloadTemplate')}/>
                              </Dropdown.Item>
                            </DropdownButton>
                          </div>
                          <div onMouseEnter={this.handleHoverEvent.bind(this)}>
                            <Icon name="info" />
                            <div className="entries-info">{GetFieldValue('downloadReadingsInfo')}</div>
                          </div>
                        </div>
                      </div>
                    </div>
                    <VehicleReadingsFilters
                      hasData={this.hasData}
                      fields={fields}
                      onFiltersChange={this.searchVehicles.bind(this)}
                      initialFilters={filters}
                      facets={this.state.facets}
                      loading={this.state.loading}
                    />
                  </div>
                </div>
              </Container>
            </MainContentHeader>
            <MainContentBody>
              <VehicleReadingList
                loading={loading}
                fields={fields}
                vehicles={vehicles}
                viewBy={filters.viewBy}
                history={this.props.history}
                fetchMoreData={this.fetchMoreData}
                onUpdateReading={this.setReadings.bind(this)}
                hasMore={this.state.hasMoreData}
                firstLoad={this.state.firstLoad}
                unitSystem={this.state.unitSystem}
                readings={this.state.readings}
                sharedAccounts={sharedAccounts}
                accounts={accounts}
                showVehicleNotFoundMessage={this.state.showVehicleNotFoundMessage}
                showNoLeaseMessage={showNoLeaseMessage}
                pendingEntry={pendingEntry}
              />
              <ToastContainer />
              {this.showVehicleSearchErrorMessage && (
                <Message
                  show={this.state.showVehicleSearchErrorMessage}
                  messageContent={this.state.vehicleSearchErrorMessage}
                  okayButtonText="CLOSE"
                  onOkay={this.handleOnOkayVehicleSearchErrorMessage.bind(this)}
                />
              )}
            </MainContentBody>
            {this.showButton && (
              <div className="button-container">
                <button id="save-close" ref={this.btnRef} className="save-changes btn btn-danger" onClick={this.saveValues} variant="danger" disabled={this.state.loading}>
                  <Text field={GetFieldValue('VehicleReadingSaveBtn')} />
                </button>
              </div>
            )}
            <Prompt
                when={when}
                message={this.handleBlockedNavigation}/>
            <Confirmation
                show={modalVisible}
                confirmationMsg={GetFieldValue('unsavedChangesConfirmationMessage')}
                confirmationButtonMessage={GetFieldValue('continueButton')}
                cancelButtonMessage={GetFieldValue('CancelButton')}
                OnCancel={this.closeModal.bind(this)}
                OnOK={this.handleConfirmNavigationClick}>
            </Confirmation>
            {this.state.uploadErrorMessage && (
                <Message
                  uploadError={true}
                  show={this.state.uploadErrorMessage}
                  messageContent={GetFieldValue('partialUploadMessage')}
                  okayButtonText="Okay"
                  onOkay={this.hideUploadErrorMessage.bind(this)}
                />
              )}

            {this.state.uploadBackendErrorMessage && (
                <ContactUsMessage
                  uploadError={true}
                  show={this.state.uploadBackendErrorMessage}
                  nowRyderEmail={GetFieldValue('nowRyderEmail')}
                  ryderPhone={GetFieldValue('ryderPhone')}
                  hideFooter={true}
                  messageContent={GetFieldValue('backendUploadErrorMessage')}
                  okayButtonText="Okay"
                  onOkay={this.hideUploadBackendErrorMessage.bind(this)}
                />
              )}
            </MainContent>
        );
    }
}

 export default withRouter(Readings)